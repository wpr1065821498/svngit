1. 关系：
     一对多：
           class Dept{

                @oneToMany
                private List<Employee> employees = new ArrayList<Emplolyee>(); //会产生3张表，有一张中间表是专门用来维护关系的

                注意：多对多的表设计和这个一对多表设计是一样的，但是它们的区别：  中间表对应的 dept_id必须得唯一吧，不能重复，如果出现了重复就变成多对多
           }


           以上这种配置是不行的，因为1对多我们只需要2张表就能达到我们想要的效果，并不需要3张表


           正确配置

           class Dept{

                @oneTomany
                @JoinColumn(name="dept_id")
                private List<Employee> employees = new ArrayList<Employee>();
           }


           1对多查询的时候，默认就是延迟加载，而我们知道查询的列表，已经不再是最单纯的Set与List了，它底层会自己有一个类来实现我们的Set与List


           注意： 申明集合类型的时候，一定要用接口，不要用实现类，因为用实现类，底层强转不了


           一对多性能太差了，不管是先添加1方还是先添加多方，它们产生的sql语句一样多     单向的1对多用的比较少


     如果真正要使用，我们应该配置双向的1对多

        这时候我们发现做保存的时候，1方总是会多发送sql语句去维护关系

        解决方案： 让一方放弃关系的维护，让多方来维护  mappedBy

        记住一句话： 以后我们都先保存1方，再保存多方，性能总是最好的


      级联：
        级联保存： 在我们保存一方的时候，多方也一并会进行一个保存



